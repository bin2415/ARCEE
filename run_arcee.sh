# the entry of Arcee
trap ctrl_c INT

RED='\033[0;31m'
NC='\033[0m' # No Color
Green='\033[0;32m'

CUR_DIR=`dirname $0`

SLEEP_BEFORE_RUN=1

# How many htmls that html generator should generate at one iteration
BATCH_NUMBER=2000

# how many pdfs that exchange object componments should generate at one iteration
EXCHANGE_OBJECT_NUM=4

DEEPFUZZ=false
SAVE_HTML=true

domato_deepfuzz=$CUR_DIR/script/domato_deepfuzz_test/generator.py
domato=$CUR_DIR/script/domato/generator.py

replace_font=$CUR_DIR/remove_font/replace_font_sort
randomly_pick=$CUR_DIR/exchange_obj/randomly_pick.py
exchange_obj=$CUR_DIR/exchange_obj/exchange_objs
test_html=$CUR_DIR/test_html/test.html
trim_html_py=$CUR_DIR/trim_html/parse_cmin_xml_parser.py
trim_pdf_py=$CUR_DIR/trim_html/trim_pdf.py

AFL_CMIN="afl-cmin"
AFL_MAP="afl-showmap"
PARSER=""
BINARY_ARGS=""

TMP_DIR=$TMPDIR

# array that stores convertors.
# if you want to add convertors. Please add here!
CONVERTOR_ARR=(google-chrome wkhtmltopdf)
#CONVERTOR_ARR=(wkhtmltopdf)

REPLACE_FONT_RATE=8 # 0.8 * 10
DECOMPRESS_RATE=0.4 # 0.4

# this is the commands that run convertors. The format is:
#   first argument is input html file
#   second argument is input pdf file
CONVERTOR_CMD_ARR=("google-chrome --headless --no-sandbox --disable-gpu %s --print-to-pdf=%s" "wkhtmltopdf %s %s")

# CONVERTOR_CMD_ARR=("wkhtmltopdf %s %s")
declare -a CONVERTOR_VALID_ID
declare -a CONVERTOR_OUTPUT
declare -a CONVERTOR_ALL_CNT

ALL_EXCHANGE_CNT=0
EXCHANGE_TMP=""
ALL_PDF_TMP=""
CMINED_PDF_DIR=""
ALL_CNT=0
PDF_OUTPUT=""

# This is the help function that clear the content of directory
# If the directory does not exist. Create it
# Arguments:
#   @dir: directory to be cleared
clear_dir_before_use(){
  dir=$1
  if [ ! -d $dir ]; then
    mkdir -p $dir
  else
    yes | rm $dir/* > /dev/null 2>&1
  fi
}

# This is the function that convert html to pdf
# Arguments: 
#   @input_dir: input directory
#   @output_dir: output directory
#   @idx: index of convertor
convert_htmls_to_pdfs(){

  input_dir=$1
  output_dir=$2
  idx=$3
  cur_convertor=${CONVERTOR_ARR[$idx]}
  valid_num_tmp=0
  for f in $input_dir/*; do

    cur_outputaaa=${output_dir}/`printf "id:%06d,%s.pdf" $valid_num_tmp $cur_convertor`

    cmd=`printf "timeout 3s ${CONVERTOR_CMD_ARR[$idx]}" $f $cur_outputaaa`

    eval $cmd > /dev/null 2>&1

    if [ -f $cur_outputaaa ]; then
      echo -en "\r\t\t Convertor ${CONVERTOR_ARR[$i]} generate pdf $cur_outputaaa succeed!"
      valid_num_tmp=$((valid_num_tmp+1))
    fi

  done
}

print_help() {
    echo "This script is used to run the toolchains automatically!"
    echo -e "\t -o <string>: output directory"
    echo -e "\t -b <number>: batch number. How many htmls should generate at once. The default number is $BATCH_NUMBER"
    echo -e "\t -e <number>: the number of pdfs that generated by exchanging objects componment. The default number is $EXCHANGE_OBJECT_NUM "
    #echo -e "\t -d: use deepfuzz-domato backend for generating htmls or not. Default is False."
    echo -e "\t -C <path of afl-cmin>: path of afl-cmin. default is afl-cmin"
    echo -e "\t -M <path of afl-showmap>: path of afl-showmap. default is afl-showmap"
    echo -e "\t -P <path of fuzzed pdf parser>"
    echo -e "\t -T <timeout of afl-cmin>"
    echo -e "\t -S <arguments of fuzzed pdf parser>"
}

init(){

    echo "[-] Init the envirments..."
    if [ -z $OUTPUT ]; then
	    print_help
	    exit -1
    fi
    cur_date_time="`date +%Y%m%d%H%M%S`"
    convertor_len=${#CONVERTOR_ARR[@]}
    convertor_cmd_len=${#CONVERTOR_CMD_ARR[@]}

    # check if afl-cmin exists
    if [ ! -x `eval "which $AFL_CMIN"` ]; then
        echo -e "${RED}Can't find afl-cmin. Please specify it with -C <cmin>${NC}"
        exit -1
    fi

    # check if the parser exists
    if [ ! -x $PARSER ]; then
        echo -e "${RED}Can't find Pdf parser or it is not an excutable file. Please specify it with -P <parser>${NC}"
        exit -1
    fi

    if [ $convertor_len -ne $convertor_cmd_len ]; then
        echo -e "\t${Red}Error: The length of convertor_cmd_arr does not equal to the length of convertor_len!${NC}"
    fi

    echo -e "\tThe number of convertors is $convertor_len"

    # 1: check if the convertors run correctly
    random_output=`base64 < /dev/urandom | tr -d 'O0Il1+/' | head -c 8; printf '\n'`
    random_output=$TMP_DIR/${random_output}
    for (( i=0; i<$convertor_len; i++ )); do 
        echo -e "\t[-] checking if convertor ${Green}${CONVERTOR_ARR[$i]}${NC} runs correctlly..."
        cmd=`printf "${CONVERTOR_CMD_ARR[$i]}" $test_html $random_output`
        eval $cmd > /dev/null 2>&1
        if [ $? -ne 0 ]; then
            echo -e "\t\t${Red}Error: testing convertor ${CONVERTOR_ARR[$i]} failed!${NC}"
            exit -1
        fi
        echo -e "\t\t[*] convertor ${CONVERTOR_ARR[$i]} runs correctlly"
    done
    rm $random_output

    # 2: mkdir the output
    for (( i=0; i<$convertor_len; i++ )); do 
        output_dir=$OUTPUT/${CONVERTOR_ARR[$i]}_${cur_date_time}
        if [ ! -d $output_dir ]; then
            echo -e "\t\t[*] mkdir $output_dir"
            mkdir -p $output_dir
        fi

        # this stores all converted pdfs
        mkdir -p ${output_dir}/.converted

        CONVERTOR_OUTPUT[$i]=$output_dir
        CONVERTOR_VALID_ID[$i]=0
        CONVERTOR_ALL_CNT[$i]=0
    done

    EXCHANGE_TMP=$OUTPUT/exchange_tmp_${cur_date_time}
    ALL_PDF_TMP=$OUTPUT/all_pdf_tmp_${cur_date_time}
    CMINED_PDF_DIR=$OUTPUT/cmined_tmp_${cur_date_time}
    PDF_OUTPUT=$OUTPUT/pdfs_${cur_date_time}
    mkdir -p $PDF_OUTPUT

    # 3: set the backend that generates html
    if [ $DEEPFUZZ = true ]; then
        BACKEND_HTML=$domato_deepfuzz
    else
        BACKEND_HTML=$domato
    fi

    echo -e "\t[*] Select the backend that generates html: $BACKEND_HTML"
    echo -e "[*] ${Green}Init the environments done!${NC}"
    echo -e "[*] ${Green}PDFs will be generated in $PDF_OUTPUT !${NC}"
}

function ctrl_c() {
    echo -e "${RED} You are entering CTRL-C, exiting...${NC}"
    kill -9 $CUR_PID > /dev/null 2>&1

    if [ $SAVE_HTML = false ]; then
        yes | rm -r $OUTPUT/html_output
    fi

    yes | rm -r $OUTPUT/exchange_tmp
    exit -1
}

# rename the file to afl format. That is "id:%6d,......"
# Arguments:
#   @dir_input: diretory that is input directory
#   @dir_output: directory that is output directory

rename_afl_format(){
  dir_input=$1
  dir_output=$2
  idx=$3

  for f in $dir_input/*; do
    tool=`echo $f | cut -d "," -f2 | cut -d "." -f1`
    cur_outputaaa=$dir_output/`printf "id:%06d,%s.pdf" $ALL_CNT $tool`

    mv $f $cur_outputaaa
    ALL_CNT=$((ALL_CNT+1))
  done
}

# remove fonts randomly
# Arguments
#   @dir: directory that store the pdf to be operated
remove_fonts(){
  dir=$1
  for f in $dir/*; do

    if [ ! -f $f ]; then
	continue
    fi

    if [ $((RANDOM%10)) -lt $REPLACE_FONT_RATE ]; then
      #echo -en "\r\t\t [*] Replace font for $f ..."
      cur_output_font=`printf "%s_nofont.pdf" ${f//\.pdf/}`

      $replace_font -i $f -o $cur_output_font > /dev/null 2>&1

      if [ -f $cur_output_font ]; then
        #echo -en "\r\t\t [*] Replace font for $f Succeed!"
        rm $f
      fi

    fi
  done
}

## decompress randomly
# Arguments
#   @dir: directory that stores the pdfs to be operated
decompress_pdfs(){
  dir=$1
  cur_files_num=`ls $dir | wc -l | awk '{print $1}'`
  decompress_num=$(echo "scale=0; $cur_files_num*$DECOMPRESS_RATE/1" | bc)

  for f in `ls -Sr $dir | head -$decompress_num`; do
    f=$dir/$f
    if [ ! -f $f ]; then
	continue
    fi

    cur_decompress=`printf '%s_decompress.pdf' ${f//\.pdf/}`
    mutool clean -d -f -i $f $cur_decompress > /dev/null 2>&1

    if [ -f $cur_decompress ]; then
      #  echo -en "\r\t\t [*] Decompress $f Succeed!"
      rm $f
    fi

  done
}

############### main running function #############
run() {
    valid_exchange_id=0
    iter_idx=0
    echo -e "[-]: Generting..."
    mkdir -p $OUTPUT/html_output

    while true; do
        cur_output_list=$OUTPUT/.cur_files.list
        echo -n "" > $cur_output_list
        # generate output
        CUR_PID=0
        echo -e "\t`date` [-]: Iteration $iter_idx, batch number $BATCH_NUMBER"
        echo -e "\t`date` [-]: Generating htmls..."
	iter_idx=$((iter_idx+1))
        cur_date_time="`date +%Y%m%d%H%M%S`"
        cur_output_dir=$OUTPUT/html_output/domato_${cur_date_time}
        html_tmp_output=$cur_output_dir/html.log
        mkdir -p $cur_output_dir
        python3 $BACKEND_HTML --output_dir $cur_output_dir --no_of_files $BATCH_NUMBER > $html_tmp_output  2>&1 &
        CUR_PID=$!

        while true; do
            last_line=`tail -n 1 $html_tmp_output`
            last_line=${last_line//\n/}
            echo -en "\r\t... $last_line"

            kill -s 0 $CUR_PID > /dev/null 2>&1
            check_pid=$?
            if [ $check_pid -ne 0 ]; then
                break
            fi
            sleep 10s
        done
        echo ""
        
        rm -rf $html_tmp_output
        echo -e "\t`date`[+] ${Green}Generate $BATCH_NUMBER html succeed!${NC}"

        # convert htmls to pdfs
        convertor_len=${#CONVERTOR_ARR[@]}

        echo -e "\t`date`[-] Converting to pdfs...!"

	clear_dir_before_use $ALL_PDF_TMP
	valid_num_tmp=0

        for f in $cur_output_dir/*.html; do
            # for every convertor
            for (( i=0; i<$convertor_len; i++)); do

                # firstly: convert all htmls to pdfs
                cur_convertor=${CONVERTOR_ARR[$i]}
                cur_valid_num=${CONVERTOR_ID[$i]}

                cur_output=${ALL_PDF_TMP}/`printf "id:%06d-first,%s.pdf" $valid_num_tmp $cur_convertor`

                cmd=`printf "timeout 3s ${CONVERTOR_CMD_ARR[$i]}" $f $cur_output`
                eval $cmd > /dev/null 2>&1

		valid_num_tmp=$((valid_num_tmp+1))

                if [ -f $cur_output ]; then
                    echo -en "`date`\r\t\t Convertor ${CONVERTOR_ARR[$i]} generate pdf $cour_output succeed!"
                    #echo "$cur_output" > $cur_output_list
                fi
            done
        done
        
        echo -e "\t`date`[*] ${Green}Convertors generate pdfs succeed!${NC}"
        if [ -d $CMINED_PDF_DIR ]; then
          yes | rm -r $CMINED_PDF_DIR 
        fi

        cmin_cmd="$AFL_CMIN -m none -i $ALL_PDF_TMP -o $CMINED_PDF_DIR -t $SHOWMAP_TIMEOUT -- $PARSER $BINARY_ARGS"
	echo $cmin_cmd
	eval $cmin_cmd

        cur_exchange_num=`ls $CMINED_PDF_DIR | wc -l | awk '{print $1}'`
        cur_exchange_num=$(($cur_exchange_num*$EXCHANGE_OBJECT_NUM))

        echo "python3 $randomly_pick -i $CMINED_PDF_DIR -o $EXCHANGE_TMP -n $cur_exchange_num"
        python3 $randomly_pick -i $CMINED_PDF_DIR -o $EXCHANGE_TMP -n $cur_exchange_num
        echo -e "\t `date` [+] Randomly picking done!"

	clear_dir_before_use $EXCHANGE_TMP/.afl_id/

        for f in $EXCHANGE_TMP/*; do
            cur_output=`printf 'id:%06d-first,exchange.pdf' $valid_exchange_id_tmp`
            mv $f ${EXCHANGE_TMP}/.afl_id/${cur_output}
            valid_exchange_id_tmp=$((valid_exchange_id_tmp+1))
        done

	clear_dir_before_use $ALL_PDF_TMP

	mv $EXCHANGE_TMP/.afl_id/* $ALL_PDF_TMP
	mv $CMINED_PDF_DIR/*.pdf $ALL_PDF_TMP


        #cmin_cmd="$AFL_CMIN -m none -i $ALL_PDF_TMP -o $CMINED_PDF_DIR -t $SHOWMAP_TIMEOUT -- $PARSER $BINARY_ARGS"

	#echo $cmin_cmd
	#eval $cmin_cmd
        #echo -e "\t `date` [+] cmin all pdfs done"

        clear_dir_before_use $ALL_PDF_TMP/.trim_pdf

        # Then. trim these pdfs
        echo -e "\t `date` [-] trmming all pdfs..."
        echo "python3 $trim_pdf_py -i $ALL_PDF_TMP -o $ALL_PDF_TMP/.trim_pdf -b $PARSER  -s $AFL_MAP $BINARY_ARGS"
        python3 $trim_pdf_py -i $ALL_PDF_TMP -o $ALL_PDF_TMP/.trim_pdf -b $PARSER  -s $AFL_MAP $BINARY_ARGS
        echo -e "\t `date` [+] trmming all pdfs done"

        rename_afl_format $ALL_PDF_TMP/.trim_pdf $ALL_PDF_TMP/.trim_pdf

        echo -e "\t `date` [-] remove fonts..."
        remove_fonts $ALL_PDF_TMP/.trim_pdf
        echo -e "\t `date` [+] remove fonts done"


        echo -e "\t `date` [-] decompress..."
        decompress_pdfs $ALL_PDF_TMP/.trim_pdf
        echo -e "\t `date` [+] decompress done"


        # Minimization and decompress are done. copy files to destination
        for cur_pdf in $ALL_PDF_TMP/.trim_pdf/*.pdf; do

          if [ ! -f $cur_pdf ]; then
            continue
          fi
	  echo $cur_pdf

          dst=$PDF_OUTPUT/`basename $cur_pdf`
          cp $cur_pdf $dst
        done
        echo -e "\t${Green}Summary: All pdfs is $ALL_CNT${NC}"
done
}

# parse arguments
echo "[-] parse args..."

SHOWMAP_TIMEOUT="none"
while getopts "T:C:P:S:M:e:o:b:sdh" arg
do
    case $arg in
        o)
            OUTPUT=$OPTARG;;
        b)
            BATCH_NUMBER=$OPTARG;;
        d)
            DEEPFUZZ=true;;
        s) 
            SAVE_HTML=true;;
        e)
            EXCHANGE_OBJECT_NUM=$OPTARG;;
        C)
            AFL_CMIN=$OPTARG;;
        M)
            AFL_MAP=$OPTARG;;
        P)
            PARSER=$OPTARG;;
        S)
            BINARY_ARGS=$OPTARG;;
	T)
	    SHOWMAP_TIMEOUT=$OPTARG;;
        h)
            print_help
	    exit 0
	    ;;
    esac
done

#check_execs

echo -e "\tDirectory of output is $OUTPUT"
echo -e "\tUse deepfuzz: $DEEPFUZZ"
echo -e "\tSave Html: $SAVE_HTML"
echo -e "\tBatch number is $BATCH_NUMBER"
echo -e "\tExchange Objects number is $EXCHANGE_OBJECT_NUM"
echo -e "${Green}[+] parse args done${NC}"

init

# Here. Let's start the trully work:)
echo -e "[*] ${Green}Ok. Everythins is setup. It is going to run in $SLEEP_BEFORE_RUN seconds...${NC}"
echo -e "[*] ${RED}If you want to stop, please enter Ctrl+C${NC}"
sleep ${SLEEP_BEFORE_RUN}s

run
